module Rblox
  class Resolver
    @runner: Runner
    @interpreter: Interpreter
    @scopes: Array[Hash[String, bool?]]
    @current_function: Symbol

    module FunctionType
      NONE: :fn_none
      FUNCTION: :fn_function
    end

    def initialize: (Runner runner, Interpreter interpreter) -> void

    def resolve: (Expr::BaseExpr | Stmt::BaseStmt | Array[Expr::BaseExpr | Stmt::BaseStmt] expr_or_stmt) -> void

    def visit_block_stmt: (Stmt::BlockStmt stmt) -> void
    def visit_expression_stmt: (Stmt::ExpressionStmt stmt) -> void
    def visit_function_stmt: (Stmt::FunctionStmt stmt) -> void
    def visit_if_stmt: (Stmt::IfStmt stmt) -> void
    def visit_print_stmt: (Stmt::PrintStmt stmt) -> void
    def visit_println_stmt: (Stmt::PrintlnStmt stmt) -> void
    def visit_return_stmt: (Stmt::ReturnStmt stmt) -> void
    def visit_var_stmt: (Stmt::VarStmt stmt) -> void
    def visit_while_stmt: (Stmt::WhileStmt stmt) -> void

    def visit_assign_expr: (Expr::AssignExpr expr) -> void
    def visit_binary_expr: (Expr::BinaryExpr expr) -> void
    def visit_call_expr: (Expr::CallExpr expr) -> void
    def visit_grouping_expr: (Expr::GroupingExpr expr) -> void
    def visit_literal_expr: (Expr::LiteralExpr _) -> void
    def visit_logical_expr: (Expr::LogicalExpr expr) -> void
    def visit_unary_expr: (Expr::UnaryExpr expr) -> void
    def visit_variable_expr: (Expr::VariableExpr expr) -> void

    private

    def resolve_function: (Stmt::FunctionStmt function, Symbol type) -> void

    def begin_scope: () -> void
    def end_scope: () -> void

    def declare: (Token name) -> void
    def define: (Token name) -> void

    def resolve_local: (Expr::BaseExpr expr, Token name) -> void
  end
end
